// SPDX-License-Identifier: LGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 SYS TEC electronic AG <https://www.systec-electronic.com/>

use std::fmt;

use crate::convert::util;
use crate::error::Result;
use crate::ffi;
use crate::{IoChannel, TempSensor};

/// PT100 / PT1000 lookup table (-50°C to 600 °C)
/// 0.803 == -50 °C
/// 1.000 ==   0 °C
/// 3.136 == 600 °C
/// (generated with scripts/gen_rtd_lut.py)
const RTD_START: f64 = -50.0;
const RTD_STEP: f64 = 1.0;
const RTD_LUT: [f64; 651] = [
    0.80306, 0.80703, 0.81100, 0.81497, 0.81894, 0.82290, 0.82687, 0.83083, 0.83479, 0.83875,
    0.84271, 0.84666, 0.85062, 0.85457, 0.85853, 0.86248, 0.86643, 0.87038, 0.87432, 0.87827,
    0.88222, 0.88616, 0.89010, 0.89404, 0.89798, 0.90192, 0.90586, 0.90980, 0.91373, 0.91767,
    0.92160, 0.92553, 0.92946, 0.93339, 0.93732, 0.94124, 0.94517, 0.94909, 0.95302, 0.95694,
    0.96086, 0.96478, 0.96870, 0.97261, 0.97653, 0.98044, 0.98436, 0.98827, 0.99218, 0.99609,
    1.00000, 1.00391, 1.00781, 1.01172, 1.01562, 1.01953, 1.02343, 1.02733, 1.03123, 1.03513,
    1.03903, 1.04292, 1.04682, 1.05071, 1.05460, 1.05849, 1.06238, 1.06627, 1.07016, 1.07405,
    1.07793, 1.08182, 1.08570, 1.08959, 1.09347, 1.09735, 1.10123, 1.10510, 1.10898, 1.11286,
    1.11673, 1.12060, 1.12447, 1.12835, 1.13221, 1.13608, 1.13995, 1.14382, 1.14768, 1.15155,
    1.15541, 1.15927, 1.16313, 1.16699, 1.17085, 1.17470, 1.17856, 1.18241, 1.18627, 1.19012,
    1.19397, 1.19782, 1.20167, 1.20552, 1.20936, 1.21321, 1.21705, 1.22090, 1.22474, 1.22858,
    1.23242, 1.23626, 1.24009, 1.24393, 1.24777, 1.25160, 1.25543, 1.25926, 1.26309, 1.26692,
    1.27075, 1.27458, 1.27840, 1.28223, 1.28605, 1.28987, 1.29370, 1.29752, 1.30133, 1.30515,
    1.30897, 1.31278, 1.31660, 1.32041, 1.32422, 1.32803, 1.33184, 1.33565, 1.33946, 1.34326,
    1.34707, 1.35087, 1.35468, 1.35848, 1.36228, 1.36608, 1.36987, 1.37367, 1.37747, 1.38126,
    1.38505, 1.38885, 1.39264, 1.39643, 1.40022, 1.40400, 1.40779, 1.41158, 1.41536, 1.41914,
    1.42293, 1.42671, 1.43049, 1.43426, 1.43804, 1.44182, 1.44559, 1.44937, 1.45314, 1.45691,
    1.46068, 1.46445, 1.46822, 1.47198, 1.47575, 1.47951, 1.48328, 1.48704, 1.49080, 1.49456,
    1.49832, 1.50208, 1.50583, 1.50959, 1.51334, 1.51710, 1.52085, 1.52460, 1.52835, 1.53210,
    1.53584, 1.53959, 1.54333, 1.54708, 1.55082, 1.55456, 1.55830, 1.56204, 1.56578, 1.56952,
    1.57325, 1.57699, 1.58072, 1.58445, 1.58818, 1.59191, 1.59564, 1.59937, 1.60309, 1.60682,
    1.61054, 1.61427, 1.61799, 1.62171, 1.62543, 1.62915, 1.63286, 1.63658, 1.64030, 1.64401,
    1.64772, 1.65143, 1.65514, 1.65885, 1.66256, 1.66627, 1.66997, 1.67368, 1.67738, 1.68108,
    1.68478, 1.68848, 1.69218, 1.69588, 1.69958, 1.70327, 1.70696, 1.71066, 1.71435, 1.71804,
    1.72173, 1.72542, 1.72910, 1.73279, 1.73648, 1.74016, 1.74384, 1.74752, 1.75120, 1.75488,
    1.75856, 1.76224, 1.76591, 1.76959, 1.77326, 1.77693, 1.78060, 1.78427, 1.78794, 1.79161,
    1.79528, 1.79894, 1.80260, 1.80627, 1.80993, 1.81359, 1.81725, 1.82091, 1.82456, 1.82822,
    1.83187, 1.83553, 1.83918, 1.84283, 1.84648, 1.85013, 1.85378, 1.85743, 1.86107, 1.86472,
    1.86836, 1.87200, 1.87564, 1.87928, 1.88292, 1.88656, 1.89019, 1.89383, 1.89746, 1.90110,
    1.90473, 1.90836, 1.91199, 1.91562, 1.91924, 1.92287, 1.92649, 1.93012, 1.93374, 1.93736,
    1.94098, 1.94460, 1.94822, 1.95183, 1.95545, 1.95906, 1.96268, 1.96629, 1.96990, 1.97351,
    1.97712, 1.98073, 1.98433, 1.98794, 1.99154, 1.99514, 1.99875, 2.00235, 2.00595, 2.00954,
    2.01314, 2.01674, 2.02033, 2.02393, 2.02752, 2.03111, 2.03470, 2.03829, 2.04188, 2.04546,
    2.04905, 2.05263, 2.05622, 2.05980, 2.06338, 2.06696, 2.07054, 2.07411, 2.07769, 2.08127,
    2.08484, 2.08841, 2.09198, 2.09555, 2.09912, 2.10269, 2.10626, 2.10982, 2.11339, 2.11695,
    2.12051, 2.12408, 2.12764, 2.13120, 2.13475, 2.13831, 2.14187, 2.14542, 2.14897, 2.15252,
    2.15608, 2.15962, 2.16317, 2.16672, 2.17027, 2.17381, 2.17736, 2.18090, 2.18444, 2.18798,
    2.19152, 2.19506, 2.19860, 2.20213, 2.20567, 2.20920, 2.21273, 2.21626, 2.21979, 2.22332,
    2.22685, 2.23038, 2.23390, 2.23743, 2.24095, 2.24447, 2.24799, 2.25151, 2.25503, 2.25855,
    2.26206, 2.26558, 2.26909, 2.27260, 2.27612, 2.27963, 2.28314, 2.28664, 2.29015, 2.29366,
    2.29716, 2.30066, 2.30417, 2.30767, 2.31117, 2.31467, 2.31816, 2.32166, 2.32516, 2.32865,
    2.33214, 2.33564, 2.33913, 2.34262, 2.34610, 2.34959, 2.35308, 2.35656, 2.36005, 2.36353,
    2.36701, 2.37049, 2.37397, 2.37745, 2.38093, 2.38440, 2.38788, 2.39135, 2.39482, 2.39829,
    2.40176, 2.40523, 2.40870, 2.41217, 2.41563, 2.41910, 2.42256, 2.42602, 2.42948, 2.43294,
    2.43640, 2.43986, 2.44331, 2.44677, 2.45022, 2.45367, 2.45713, 2.46058, 2.46403, 2.46747,
    2.47092, 2.47437, 2.47781, 2.48125, 2.48470, 2.48814, 2.49158, 2.49502, 2.49845, 2.50189,
    2.50533, 2.50876, 2.51219, 2.51562, 2.51906, 2.52248, 2.52591, 2.52934, 2.53277, 2.53619,
    2.53961, 2.54304, 2.54646, 2.54988, 2.55330, 2.55672, 2.56013, 2.56355, 2.56696, 2.57038,
    2.57379, 2.57720, 2.58061, 2.58402, 2.58743, 2.59083, 2.59424, 2.59764, 2.60105, 2.60445,
    2.60785, 2.61125, 2.61465, 2.61804, 2.62144, 2.62483, 2.62823, 2.63162, 2.63501, 2.63840,
    2.64179, 2.64518, 2.64857, 2.65195, 2.65534, 2.65872, 2.66210, 2.66548, 2.66886, 2.67224,
    2.67562, 2.67900, 2.68237, 2.68574, 2.68912, 2.69249, 2.69586, 2.69923, 2.70260, 2.70597,
    2.70933, 2.71270, 2.71606, 2.71942, 2.72278, 2.72614, 2.72950, 2.73286, 2.73622, 2.73957,
    2.74293, 2.74628, 2.74963, 2.75298, 2.75633, 2.75968, 2.76303, 2.76638, 2.76972, 2.77307,
    2.77641, 2.77975, 2.78309, 2.78643, 2.78977, 2.79311, 2.79644, 2.79978, 2.80311, 2.80644,
    2.80978, 2.81311, 2.81643, 2.81976, 2.82309, 2.82641, 2.82974, 2.83306, 2.83638, 2.83971,
    2.84303, 2.84634, 2.84966, 2.85298, 2.85629, 2.85961, 2.86292, 2.86623, 2.86954, 2.87285,
    2.87616, 2.87947, 2.88277, 2.88608, 2.88938, 2.89268, 2.89599, 2.89929, 2.90258, 2.90588,
    2.90918, 2.91247, 2.91577, 2.91906, 2.92235, 2.92565, 2.92894, 2.93222, 2.93551, 2.93880,
    2.94208, 2.94537, 2.94865, 2.95193, 2.95521, 2.95849, 2.96177, 2.96505, 2.96832, 2.97160,
    2.97487, 2.97814, 2.98142, 2.98469, 2.98795, 2.99122, 2.99449, 2.99775, 3.00102, 3.00428,
    3.00754, 3.01080, 3.01406, 3.01732, 3.02058, 3.02384, 3.02709, 3.03035, 3.03360, 3.03685,
    3.04010, 3.04335, 3.04660, 3.04985, 3.05309, 3.05634, 3.05958, 3.06282, 3.06606, 3.06930,
    3.07254, 3.07578, 3.07902, 3.08225, 3.08549, 3.08872, 3.09195, 3.09518, 3.09841, 3.10164,
    3.10487, 3.10810, 3.11132, 3.11454, 3.11777, 3.12099, 3.12421, 3.12743, 3.13065, 3.13386,
    3.13708,
];

fn calc_temp(sensor_type: ffi::IoTmpSensorType, resistance: f64) -> f64 {
    let resistance = match sensor_type {
        ffi::IoTmpSensorType::PT100 => resistance / 100.0,
        ffi::IoTmpSensorType::PT1000 => resistance / 1000.0,
    };

    util::reverse_lookup(&RTD_LUT, resistance, RTD_START, RTD_STEP)
}

/// Struct which wraps an analog input and makes it configurable via two digital outputs
pub struct RtdCalc<T: TempSensor<f64>> {
    inner: T,
    sensor_type: ffi::IoTmpSensorType,
}

impl<T: TempSensor<f64>> fmt::Debug for RtdCalc<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "rtd/RtdCalc {:?}", self.sensor_type)
    }
}

impl<T: TempSensor<f64>> RtdCalc<T> {
    pub fn new(inner: T) -> RtdCalc<T> {
        RtdCalc {
            inner,
            sensor_type: ffi::IoTmpSensorType::PT100,
        }
    }
}

impl<T: TempSensor<f64>> IoChannel for RtdCalc<T> {
    fn init(&mut self, chan_number: usize) -> Result<()> {
        self.inner.init(chan_number)
    }

    fn shutdown(&mut self) -> Result<()> {
        self.inner.shutdown()
    }
}

impl<T: TempSensor<f64>> TempSensor<f64> for RtdCalc<T> {
    fn get(&mut self) -> Result<f64> {
        let ohms = self.inner.get()?;
        Ok(calc_temp(self.sensor_type, ohms))
    }

    fn set_mode(&mut self, _mode: ffi::IoTmpMode, sensor_type: ffi::IoTmpSensorType) -> Result<()> {
        use ffi::IoTmpSensorType::*;

        match sensor_type {
            PT100 | PT1000 => self.sensor_type = sensor_type,
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lookup_plausibility_test() {
        let iter1 = RTD_LUT.iter();
        let mut iter2 = RTD_LUT.iter();
        iter2.next().unwrap();

        for (a, b) in iter1.zip(iter2) {
            assert!(a < b);
        }
    }

    #[test]
    fn calc_temp_test() {
        assert_eq!(
            std::f64::NEG_INFINITY,
            calc_temp(ffi::IoTmpSensorType::PT100, 100.0 * RTD_LUT[0] - 1e-10)
        );

        assert!(approx_eq!(
            f64,
            -50.0,
            calc_temp(ffi::IoTmpSensorType::PT100, 100.0 * RTD_LUT[0] + 1e-10),
            epsilon = 1e-6
        ));

        dbg!(calc_temp(ffi::IoTmpSensorType::PT100, 100.0));
        assert!(approx_eq!(
            f64,
            0.0,
            calc_temp(ffi::IoTmpSensorType::PT100, 100.0),
            epsilon = 1e-6
        ));

        assert!(approx_eq!(
            f64,
            600.0,
            calc_temp(ffi::IoTmpSensorType::PT100, 100.0 * RTD_LUT[650] - 1e-10),
            epsilon = 1e-6
        ));

        assert_eq!(
            std::f64::INFINITY,
            calc_temp(ffi::IoTmpSensorType::PT100, 100.0 * RTD_LUT[650] + 1e-10)
        );
    }

    #[test]
    fn calc_temp_tenths_test() {
        // 1/10 °C (for temperatures near 0 °C, PT100)
        let step = (RTD_LUT[51] - RTD_LUT[50]) / 10.0 * 100.0;

        let testcases = vec![
            (-1.0, 100.0 - step * 10.0),
            (-0.9, 100.0 - step * 9.0),
            (-0.8, 100.0 - step * 8.0),
            (-0.7, 100.0 - step * 7.0),
            (-0.6, 100.0 - step * 6.0),
            (-0.5, 100.0 - step * 5.0),
            (-0.4, 100.0 - step * 4.0),
            (-0.3, 100.0 - step * 3.0),
            (-0.2, 100.0 - step * 2.0),
            (-0.1, 100.0 - step * 1.0),
            (0.0, 100.0),
            (0.1, 100.0 + step * 1.0),
            (0.2, 100.0 + step * 2.0),
            (0.3, 100.0 + step * 3.0),
            (0.4, 100.0 + step * 4.0),
            (0.5, 100.0 + step * 5.0),
            (0.6, 100.0 + step * 6.0),
            (0.7, 100.0 + step * 7.0),
            (0.8, 100.0 + step * 8.0),
            (0.9, 100.0 + step * 9.0),
            (1.0, 100.0 + step * 10.0),
        ];

        for (expected_temp, resistance) in testcases {
            assert!(approx_eq!(
                f64,
                expected_temp,
                calc_temp(ffi::IoTmpSensorType::PT100, resistance),
                epsilon = 1e-6
            ));
        }
    }
}
