// SPDX-License-Identifier: LGPL-3.0-or-later
//
// (c) SYSTEC electronic AG, D-08468 Heinsdorfergrund, Am Windrad 2
//     www.systec-electronic.com

#ifndef _SYSWORXX_IO_H_
#define _SYSWORXX_IO_H_

/* Warning, this file is autogenerated. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * @brief Analog channel mode type
 */
enum IoAnalogMode
{
    IoAnalogMode_Voltage = 0,
    IoAnalogMode_Current = 1,
};
typedef uint8_t IoAnalogMode;

/**
 * @brief Boolean type for usage of this API
 */
enum IoBool
{
    IoBool_False = 0,
    IoBool_True = 1,
};
typedef uint8_t IoBool;

/**
 * @brief Counter direction type can be used to invert the direction of counting.
 */
enum IoCntDirection
{
    IoCntDirection_Up = 0,
    IoCntDirection_Down = 1,
};
typedef uint8_t IoCntDirection;

/**
 * @brief Counter mode type
 */
enum IoCntMode
{
    /**
     * The counter will count edges on digital input 14. The direction of
     * counting is determined by the value of digital input 15.
     */
    IoCntMode_Counter = 0,
    /**
     * The counter will count in A/B decoder mode. Digital input 14 is used
     * for the 'A' input and digital input 15 is used for 'B'. Switching the
     * inputs will result in inverse counting.
     */
    IoCntMode_ABEncoder = 1,
};
typedef uint8_t IoCntMode;

/**
 * @brief Counter trigger type (only applies when in mode "counter")
 */
enum IoCntTrigger
{
    IoCntTrigger_RisingEdge = 0,
    IoCntTrigger_FallingEdge = 1,
    IoCntTrigger_AnyEdge = 2,
};
typedef uint8_t IoCntTrigger;

/**
 * @brief Trigger type for asynchronous digital input handling
 */
enum IoInputTrigger
{
    /**
     * Disable interrupt handling for the channel
     */
    IoInputTrigger_None = 0,
    /**
     * Enable interrupt handling if the input value changes from low to high
     */
    IoInputTrigger_RisingEdge = 1,
    /**
     * Enable interrupt handling if the input value changes from high to low
     */
    IoInputTrigger_FallingEdge = 2,
    /**
     * Enable interrupt handling if the input value changes any way
     */
    IoInputTrigger_BothEdge = 3,
};
typedef uint8_t IoInputTrigger;

enum IoResult
{
    /**
     * Function call succeeded
     */
    IoResult_Success = 0,
    /**
     * Generic error occurred
     */
    IoResult_Error = 255,
    /**
     * The functionality is not implemented by the library
     */
    IoResult_NotImplemented = 254,
    /**
     * One of the given parameters is invalid (e.g. NULL pointer or parameter is out of range)
     */
    IoResult_InvalidParameter = 253,
    /**
     * The provided channel number is invalid
     */
    IoResult_InvalidChannel = 252,
    /**
     * The provided mode is invalid
     */
    IoResult_InvalidMode = 251,
    /**
     * The provided timebase is invalid
     */
    IoResult_InvalidTimebase = 250,
    /**
     * The provided delta parameter is invalid
     */
    IoResult_InvalidDelta = 249,
    /**
     * The PTO table is completely filled
     */
    IoResult_PtoParamTabFull = 248,
    /**
     * Access to the device or peripheral has failed
     */
    IoResult_DevAccessFailed = 247,
    /**
     * Reserved error code; currently unused.
     */
    IoResult_Reserved0 = 246,
    /**
     * Reserved error code; currently unused.
     */
    IoResult_Reserved1 = 245,
    /**
     * Reserved error code; currently unused.
     */
    IoResult_ShpImgError = 244,
    /**
     * Reserved error code; currently unused.
     */
    IoResult_AddressOutOfRange = 243,
    /**
     * The watchdog did timeout
     */
    IoResult_WatchdogTimeout = 242,
};
typedef uint32_t IoResult;

/**
 * @brief Temperature channel modes
 */
enum IoTmpMode
{
    IoTmpMode_RtdTwoWire = 0,
    IoTmpMode_RtdThreeWire = 1,
    IoTmpMode_RtdFourWire = 2,
};
typedef uint8_t IoTmpMode;

/**
 * @brief Temperature channel types
 */
enum IoTmpSensorType
{
    IoTmpSensorType_PT100 = 0,
    IoTmpSensorType_PT1000 = 1,
};
typedef uint8_t IoTmpSensorType;

/**
 * @brief Hardware information structure
 *
 * This structure will be filled by IoGetHardwareInfo. It contains the
 * revision information as well as the channel counts for the different
 * peripherals.
 */
struct IoHwInfo
{
    /**
     * The PCB revision number
     */
    uint8_t m_uPcbRevision;
    /**
     * Number of digital inputs
     */
    uint8_t m_uDiChannels;
    /**
     * Number of digital outputs
     */
    uint8_t m_uDoChannels;
    /**
     * Number of analog inputs
     */
    uint8_t m_uAiChannels;
    /**
     * Number of analog outputs
     */
    uint8_t m_uAoChannels;
    /**
     * Number of temperature inputs
     */
    uint8_t m_uTmpChannels;
    /**
     * Number of counter channels
     */
    uint8_t m_uCntChannels;
    /**
     * Number of A/B decoder channels
     */
    uint8_t m_uEncChannels;
    /**
     * Number of PWM channels
     */
    uint8_t m_uPwmChannels;
};

/**
 * Callback function for changes on digital inputs
 */
typedef void (*IoInputCallback)(uint8_t, IoBool);

/**
 * @brief Initializes the I/O driver.
 * @note This function has to be called before any of the other API
 *       functions can be used.
 *
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoInit(void);

/**
 * @brief De-initialization of the I/O driver
 *
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoShutdown(void);

/**
 * @brief Get the version of the I/O driver
 *
 * @param puMajor_p Pointer to the resulting major part of the version number
 * @param puMinor_p Pointer to the resulting minor part of the version number
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetVersion(uint8_t *puMajor_p, uint8_t *puMinor_p);

/**
 * @brief Get the tickcount of the system in milliseconds
 *
 * This is a increasing time value starting at an unknown point in
 * time.
 *
 * @param puTickCount_p Pointer to the resulting timestamp value
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetTickCount(uint32_t *puTickCount_p);

/**
 * @brief Enable the systems watchdog
 *
 * @param fMonitorOnly_p Enable monitoring only mode. If the watchdog was not
 *        serviced in time, an error will be reported by the return value of
 *        IoServiceWatchdog().
 *
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoEnableWatchdog(IoBool fMonitorOnly_p);

/**
 * @brief Service the system watchdog
 *
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoServiceWatchdog(void);

/**
 * @brief Get information about device revision and available I/O channels
 *
 * @param pHwInfo_p Destination structure with the resulting information
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetHardwareInfo(struct IoHwInfo *pHwInfo_p);

/**
 * @brief Set the RUN LED
 *
 * @param fState_p The state to set
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoSetRunLed(IoBool fState_p);

/**
 * @brief Set the ERROR LED
 *
 * @param fState_p The state to set
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoSetErrLed(IoBool fState_p);

/**
 * @brief Get value of the RUN switch
 *
 * @param pfRunSwitch_p Pointer to the value destination
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetRunSwitch(IoBool *pfRunSwitch_p);

/**
 * @brief Get value of the config switch
 *
 * @param pfConfig_p Pointer to the value destination
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetConfigEnabled(IoBool *pfConfig_p);

/**
 * @brief Set the value of a digital output
 *
 * @param uChannel_p The channel of the digital output
 * @param fEnable_p The value to set
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoSetOutput(uint8_t uChannel_p, IoBool fEnable_p);

/**
 * @brief Get the value of a digital input
 *
 * @param uChannel_p The channel of the digital input
 * @param pfState_p Pointer to the state destination
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoGetInput(uint8_t uChannel_p, IoBool *pfState_p);

/**
 * @brief Register a callback to signal changes on an digital input
 *
 * @param uChannel_p The channel of the digital input
 * @param pfnCallback_p The callback function to register of type #IoInputCallback
 * @param uInterruptTrigger_p Set the kind of trigger for the input #IoInputTrigger
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoRegisterInputCallback(uint8_t uChannel_p,
                                 IoInputCallback pfnCallback_p,
                                 IoInputTrigger uInterruptTrigger_p);

/**
 * @brief Un-register / disable interrupt handling for a digital input
 *
 * @param uChannel_p Analogous to #IoRegisterInputCallback
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoUnregisterInputCallback(uint8_t uChannel_p);

/**
 * @brief Get the value of an ADC channel
 *
 * @param uChannel_p The channel to get
 * @param puAdcValue_p Pointer to the value destination
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoAdcGetValue(uint8_t uChannel_p, uint16_t *puAdcValue_p);

/**
 * @brief Setup an ADC channel for voltage or current measurement
 *
 * If a ADC does not support a specific mode or sensor type the error IoResult_NotImplemented
 * will be returned.
 *
 * @param uChannel_p The channel to setup
 * @param uMode_p The mode of type #IoAnalogMode
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoAdcSetMode(uint8_t uChannel_p,
                      IoAnalogMode uMode_p);

/**
 * @brief Set DAC output value
 *
 * @param uChannel_p The channel to set
 * @param uValue_p The value to set
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoDacSetValue(uint8_t uChannel_p, uint16_t uValue_p);

/**
 * @brief Set mode of a given temperature sensor
 *
 * If a sensor does not support a specific mode or sensor type the error IoResult_NotImplemented
 * will be returned.
 *
 * @param uChannel_p The temperature sensor channel
 * @param uMode_p The mode of type temperature sensor
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoTmpSetMode(uint8_t uChannel_p,
                      IoTmpMode uMode_p,
                      IoTmpSensorType uType_p);

/**
 * @brief Get the value of a temperature sensor
 *
 * @param uChannel_p The temperature sensor channel
 * @param piValue_p Pointer to the value destination in 1/10000 °C
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoTmpGetValue(uint8_t uChannel_p, int32_t *piValue_p);

/**
 * @brief Enable/disable a counter channel
 *
 * @param uChannel_p The channel to control
 * @param fEnable_p Enable with true value, false will disable it
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoCntEnable(uint8_t uChannel_p, IoBool fEnable_p);

/**
 * @brief Setup the counters mode
 *
 * @param uChannel_p The channel to setup
 * @param uMode_p The mode of the counter, see IoCntMode
 * @param uTrigger_p The trigger of the counter, see IoCntTrigger
 * @param uDir_p The direction of counting, see IoCntDirection
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoCntSetup(uint8_t uChannel_p,
                    IoCntMode uMode_p,
                    IoCntTrigger uTrigger_p,
                    IoCntDirection uDir_p);

/**
 * @brief Set the initial value of the counter
 *
 * @param uChannel_p The channel to setup
 * @param iPreload_p The initial value to set
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoCntSetPreload(uint8_t uChannel_p, int32_t iPreload_p);

/**
 * @brief Get the value of a counter channel
 *
 * @param uChannel_p The channel to get the value for
 * @param piValue_p Pointer to the value destination
 * @return IoResult Driver result code of type IoResult
 */
IoResult IoCntGetValue(uint8_t uChannel_p, int32_t *piValue_p);

#endif /* _SYSWORXX_IO_H_ */
